(***********************************************************************)
(*                                                                     *)
(*                   OCaml interface to Sundials                       *)
(*                                                                     *)
(*  Timothy Bourke (Inria), Jun Inoue (Inria), and Marc Pouzet (LIENS) *)
(*                                                                     *)
(*  Copyright 2014 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under a BSD 2-Clause License, refer to the file LICENSE.           *)
(*                                                                     *)
(***********************************************************************)

(**
  {2 Direct Linear Solvers. }

  @version VERSION()
  @author Timothy Bourke (Inria)
  @author Jun Inoue (Inria)
  @author Marc Pouzet (LIENS)

  @cvode <node9#s:dls>  The DLS Modules
 *)

(**
 Thrown by the getrf functions if a zero diagonal element is encountered during
 factorization. The argument indicates the column index (from 1).

 @cvode <node9#ss:dense> DenseGETRF/denseGETRF 
 *)
exception ZeroDiagonalElement of int

(** {3 Dense matrices}
    @cvode <node9#ss:dense> The DENSE Module *)

(** Operations for creating and manipulating dense matrices. *)
module DenseMatrix :
  sig
    (**
    This type represents a [DlsMat] returned from a call to {!make}.

     @cvode <node9#s:dls>  Type DlsMat
     @cvode <node9#ss:dense> NewDenseMat 
     *)
    type t

    (** A {{:OCAML_DOC_ROOT(Bigarray.Array2)} (Bigarray)} 2D vector of floats. *)
    type data = (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array2.t

    (** This exception is thrown if an operation is passed a value on which
        {!invalidate} has been called. *)
    exception Invalidated

    (** {4 Basic access} *)

    (**
     [make m n v] returns an [m] by [n] dense matrix with all elements set to
     [v].

     @cvode <node9#ss:dense> NewDenseMat
     *)
    val make : int -> int -> float -> t

    (**
     [create m n] returns an [m] by [n]  dense matrix.

     @cvode <node9#ss:dense> NewDenseMat
     *)
    val create : int -> int -> t

    (** Separate the underlying {!data} array (whose dimensions are set to
        zero) from the abstract value. This low-level operation is called
        internally when an abstract value in the underlying C library
        ceases to exist. *)
    val invalidate : t -> unit

    (**
     [m, n = size a] returns the number of columns, [m], and rows, [n], of the
     dense matrix [a].
     *)
    val size  : t -> (int * int)

    (**
     Prints a dense matrix to stdout.

     @cvode <node9#ss:dense> PrintMat
     *)
    val print : t -> unit

    (**
     [get a i j] returns the value at row [i] and column [j] in [a].

     @cvode <node9#s:dls> DENSE_ELEM
     *)
    val get : t -> int -> int -> float

    (**
     [set a i j v] stores the value [v] at row [i] and column [j] in [a].

     @cvode <node9#s:dls> DENSE_ELEM
     *)
    val set : t -> int -> int -> float -> unit

    (** {4 Calculations} *)

    (**
     Fills the matrix with zeros.

     @cvode <node9#ss:dense> SetToZero
     *)
    val set_to_zero    : t -> unit

    (**
     Increments a square matrix by the identity matrix.

     @cvode <node9#ss:dense> AddIdentity
     *)
    val add_identity   : t -> unit

    (**
     [copy src dst] copies the contents of one matrix into another.

     @cvode <node9#ss:dense> DenseCopy
     *)
    val copy     : t -> t -> unit

    (**
     [scale c a] multiplies each element of [a] by [c].

     @cvode <node9#ss:dense> DenseScale
     *)
    val scale    : float -> t -> unit

    (**
     [getrf a p] performs the LU factorization of the square matrix [a] with
     partial pivoting according to [p]. The values in [a] are overwritten with
     those of the calculated L and U matrices. The diagonal belongs to U. The
     diagonal of L is all 1s. Multiplying L by U gives a permutation of [a],
     according to the values of [p]: [p.{k} = j] means that rows [k] and [j]
     were swapped (in order, where [p.{0}] swaps against the original matrix
     [a]).

     @cvode <node9#ss:dense> DenseGETRF
     @raise ZeroDiagonalElement Zero found in matrix diagonal
     *)
    val getrf    : t -> Sundials.LintArray.t -> unit

    (**
     [getrs a p b] finds the solution of [ax = b] using LU factorization
     generated by {!getrf}.

     @cvode <node9#ss:dense> DenseGETRS
     *)
    val getrs    : t -> Sundials.LintArray.t -> Sundials.RealArray.t -> unit

    (**
     Performs Cholesky factorization of a real symmetric positive matrix.

     @cvode <node9#ss:dense> DensePOTRF
     *)
    val potrf    : t -> unit

    (**
     [potrs a b] finds the solution of [ax = b] using the Cholesky factorization
     generated by {!potrf}. [a] must be an n by n matrix and [b] must be of
     length n.

     @cvode <node9#ss:dense> DensePOTRS
     *)
    val potrs    : t -> Sundials.RealArray.t -> unit

    (**
     [geqrf a beta work] performs the QR factorization of an
     m by n matrix [a], where m >= n. The [beta] vector must be of length n.
     The [work] vector must be of length m.

     @cvode <node9#ss:dense> DenseGEQRF
     *)
    val geqrf    : t -> Sundials.RealArray.t -> Sundials.RealArray.t -> unit

    (**
     [ormqr a beta v w work] computes the product [w = Qv], with Q calculated
     using {!geqrf}, where [a] is an m by n matrix with m >= n, [beta] is of
     length n, [v] is of length n, [w] is of length m, and [work] is of length
     m.

     @param a       matrix passed to {!geqrf}
     @param beta    vector apssed to {!geqrf}
     @param v       vector multiplier
     @param w       result vector
     @param work    temporary vector used in the calculation
     @cvode <node9#ss:dense> DenseORMQR
     *)
    val ormqr :
      a:t -> beta:Sundials.RealArray.t -> v:Sundials.RealArray.t ->
      w:Sundials.RealArray.t -> work:Sundials.RealArray.t -> unit

  end

(** {3 Array-based dense matrices}
    @cvode <node9#ss:dense> The DENSE Module *)

(** Operations for creating and manipulating dense matrices based on arrays. *)
module ArrayDenseMatrix :
  sig
    (**
     This type represents a two-dimensional matrix returned from a call to
     {!make}, {!Sundials.RealArray2.make}, or {!Sundials.RealArray2.wrap}.

     @cvode <node9#ss:dense> Small dense matrices
     @cvode <node9#ss:dense> newDenseMat 
     *)
    type t = Sundials.RealArray2.t

    (** {4 Basic access} *)

    (**
     [make m n v] returns an [m] by [n] dense small matrix with all elements set
     to [v].

     @cvode <node9#ss:dense> newDenseMat
     *)
    val make : int -> int -> float -> t

    (**
     [create m n] returns an [m] by [n] dense small matrix.

     @cvode <node9#ss:dense> newDenseMat
     *)
    val create : int -> int -> t

    (**
     [get a i j] returns the value at row [i] and column [j] in [a].
     *)
    val get : t -> int -> int -> float

    (**
     [set a i j v] stores the value [v] at row [i] and column [j] in [a].
     *)
    val set : t -> int -> int -> float -> unit

    (** Fills the matrix with zeros. *)
    val set_to_zero    : t -> unit

    (** {4 Calculations} *)

    (**
     [copy src dst] copies the contents of one matrix into another. Both
     must have the same size.

     @cvode <node9#ss:dense> denseCopy
     *)
    val copy  : t -> t -> unit

    (*
     [scale c a] multiplies each element of [a] by [c].

     @cvode <node9#ss:dense> denseScale
     *)
    val scale : float -> t -> unit

    (**
     [add_identity a] increments the (square) matrix [a] by the identity matrix.

     @cvode <node9#ss:dense> denseAddIdentity
     *)
    val add_identity : t -> unit

    (**
     [getrf a p] performs the LU factorization of the square matrix [a] with
     partial pivoting according to [p]. The values in [a] are overwritten with
     those of the calculated L and U matrices. The diagonal belongs to U. The
     diagonal of L is all 1s. Multiplying L by U gives a permutation of [a],
     according to the values of [p]: [p.{k} = j] means that rows [k] and [j]
     were swapped (in order, where [p.{0}] swaps against the original matrix
     [a]).

     @cvode <node9#ss:dense> denseGETRF
     @raise ZeroDiagonalElement Zero found in matrix diagonal
     *)
    val getrf : t -> Sundials.LintArray.t -> unit

    (**
     [getrs a p b] finds the solution of [ax = b] using LU factorization
     generated by {!getrf}.

     @cvode <node9#ss:dense> denseGETRS
     *)
    val getrs : t -> Sundials.LintArray.t -> Sundials.RealArray.t -> unit

    (** Like {!getrs} but stores [b] starting at the given offset. *)
    val getrs' : t -> Sundials.LintArray.t -> Sundials.RealArray.t -> int -> unit

    (**
     [potrf a] performs the Cholesky factorization of a real symmetric positive
     n by n matrix.

     @cvode <node9#ss:dense> densePOTRF
     *)
    val potrf : t -> unit

    (**
     [potrs a b] finds the solution of [ax = b] using the Cholesky factorization
     generated by {!potrf}. [a] must be an n by n matrix and [b] must be of
     length n.

     @cvode <node9#ss:dense> densePOTRS
     *)
    val potrs : t -> Sundials.RealArray.t -> unit

    (**
     [geqrf a beta work] performs the QR factorization of an
     m by n matrix, where m >= n. The [beta] vector must be of length n.
     The [work] vector must be of length m.

     @cvode <node9#ss:dense> denseGEQRF
     *)
    val geqrf : t -> Sundials.RealArray.t -> Sundials.RealArray.t -> unit

    (**
     [ormqr a beta v w work] computes the product [w = Qv], with Q calculated
     using {!geqrf}, where [a] is an m by n matrix with m >= n, [beta] is of
     length n, [v] is of length n, [w] is of length m, and [work] is of length
     m.

     @param a       matrix passed to {!geqrf}
     @param beta    vector apssed to {!geqrf}
     @param v       vector multiplier
     @param w       result vector
     @param work    temporary vector used in the calculation
     @cvode <node9#ss:dense> denseORMQR
     *)
    val ormqr :
      a:t -> beta:Sundials.RealArray.t ->
      v:Sundials.RealArray.t -> w:Sundials.RealArray.t ->
        work:Sundials.RealArray.t -> unit
  end

(** {3 Banded matrices}
    @cvode <node9#ss:band> The BAND Module *)

(** Operations for creating and manipulating banded matrices. *)
module BandMatrix :
  sig
    (**
    This type represents a [DlsMat] returned from a call to
    {!make}.

     @cvode <node9#s:dls>  Type DlsMat
     @cvode <node9#ss:band> NewBandMat 
     *)
    type t

    (** A {{:OCAML_DOC_ROOT(Bigarray.Array2)} (Bigarray)} 2D vector of floats. *)
    type data = (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array2.t

    (** This exception is thrown if an operation is passed a value on which
        {!invalidate} has been called. *)
    exception Invalidated

    (** {4 Basic access} *)

    (**
     [make n mu ml smu v] returns an [n] by [n] band matrix of upper bandwidth
     [mu], lower bandwidth [ml], and storage upper bandwidth [smu] with all
     elements set to [v]. Pass [smu] = [mu] if the result will not be LU
     factored, otherwise pass [smu] = min([n]-1, [mu] + [ml]). In the latter
     case, the extra space is used to store U after a call to {!gbtrf}.

     @cvode <node9#ss:band> NewBandMat
     *)
    val make : int -> int -> int -> int -> float -> t

    (**
     [create n mu ml smu] returns an [n] by [n] band matrix of upper bandwidth
     [mu], lower bandwidth [ml], and storage upper bandwidth [smu]. Pass
     [smu] = [mu] if the result will not be LU factored, otherwise pass
     [smu] = min([n]-1, [mu] + [ml]). In the latter case, the extra space is
     used to store U after a call to {!gbtrf}.

     @cvode <node9#ss:band> NewBandMat
     *)
    val create : int -> int -> int -> int -> t

    (** Separate the underlying {!data} array (whose dimensions are set to
        zero) from the abstract value. This low-level operation is called
        internally when an abstract value in the underlying C library
        ceases to exist. *)
    val invalidate : t -> unit

    (**
     [n, mu, ml, smu = size a] returns the size ([n]), upper bandwidth ([mu]),
     lower bandwidth ([ml]), and upper storage bandwidth ([smu]) of the band
     matrix [a].
     *)
    val size  : t -> (int * int * int * int)

    (**
     Prints a band matrix to stdout.

     @cvode <node9#ss:band> PrintMat
     *)
    val print : t -> unit

    (**
     [get a i j] returns the value at row [i] and column [j] of the n by n
     matrix [a], where [i <= j + ml] and [j <= i + (s)mu].

     @cvode <node9#s:dls> BAND_ELEM
     *)
    val get : t -> int -> int -> float

    (**
      [set a i j v] stores the value [v] at row [i] and column [j] of the
      n by n matrix [a], where [i <= j + ml] and [j <= i + (s)mu].

      @cvode <node9#s:dls> BAND_ELEM
     *)
    val set : t -> int -> int -> float -> unit

    (** {4 Calculations} *)

    (**
     Fills the matrix with zeros.

     @cvode <node9#ss:band> SetToZero
     *)
    val set_to_zero    : t -> unit

    (**
     Increment a square matrix by the identity matrix.

     @cvode <node9#ss:band> AddIdentity
     *)
    val add_identity   : t -> unit

    (**
     [copy src dst copymu copyml] copies the submatrix with upper and lower
     bandwidths [copymu] and [copyml] of the band matrix [src] into the
     band matrix [dst].

     @cvode <node9#ss:band> BandCopy
     *)
    val copy : t -> t -> int -> int -> unit

    (**
     [scale c a] multiplies each element of [a] by [c].

     @cvode <node9#ss:band> BandScale
     *)
    val scale : float -> t -> unit

    (**
     [gbtrf a p] performs the LU factorization of [a] with partial pivoting
     according to [p]. The values in [a] are overwritten with those of the
     calculated L and U matrices. The diagonal belongs to U. The diagonal of L
     is all 1s. U may occupy elements up to bandwidth [smu] (rather than to
     [mu]).

     @cvode <node9#ss:band> BandGBTRF
     *)
    val gbtrf : t -> Sundials.LintArray.t -> unit

    (**
     [gbtrs a p b] finds the solution of [ax = b] using an LU factorization
     found by {!gbtrf}. Both [p] and [b] must have the same number of rows as
     [a].

     @cvode <node9#ss:band> BandGBTRS
     *)
    val gbtrs : t -> Sundials.LintArray.t -> Sundials.RealArray.t -> unit
  end

(** {3 Array-based banded matrices}
    @cvode <node9#ss:band> The BAND Module *)

(** Operations for creating and manipulating banded matrices based on arrays. *)
module ArrayBandMatrix :
  sig
    (**
     This type represents a two-dimensional matrix returned from a call to
     {!make}, {!Sundials.RealArray2.make}, or {!Sundials.RealArray2.wrap}.

     @cvode <node9#ss:band> newBandMat 
     *)
    type t = Sundials.RealArray2.t

    (** {4 Basic access} *)

    (**
     [create n smu ml] returns an [n] by [n] band matrix with
     storage upper bandwidth [smu] and lower half-bandwidth [ml].
     Pass [smu] = [mu] if the result will not be LU factored, otherwise pass
     [smu] = min([n]-1, [mu] + [ml]). In the latter case, the extra space is
     used to store U after a call to {!gbtrf}.

     @cvode <node9#ss:band> newBandMat
     *)
    val create : int -> int -> int -> t

    (**
     [get a smu i j] returns the value at row [i] and column [j] in the 
     band matrix [a] with storage upper bandwidth [smu], where
     [i <= j + ml] and [j <= i + mu].
     *)
    val get : t -> int -> int -> int -> float

    (**
     [set a smu i j v] stores the value [v] at row [i] and column [j] in the
     band matrix [a] with storage upper bandwidth [smu], where
     [i <= j + ml] and [j <= i + mu].
     *)
    val set : t -> int -> int -> int -> float -> unit

    (** {4 Calculations} *)

    (**
     [copy src dst a_smu b_smu copymu copyml] copies the submatrix with
     upper and lower bandwidths [copymu] and [copyml] of the band
     matrix [src] into the band matrix [dst]. Both matrices must be
     of the same size.

     @cvode <node9#ss:band> bandCopy
     *)
    val copy : t -> t -> int -> int -> int -> int -> unit

    (**
     [scale c a mu ml smu] multiplies each element of the band matrix [a], of
     upper bandwidth [mu], lower bandwidth [ml], and storage upper bandwidth
     [smu], by [c].

     @cvode <node9#ss:band> bandScale
     *)
    val scale : float -> t -> int -> int -> int -> unit

    (**
     [add_identity a smu] increments the band matrix [a] of storage upper
     bandwidth [smu] by the identity matrix.

     @cvode <node9#ss:band> bandAddIdentity
     *)
    val add_identity : t -> int -> unit

    (**
     [gbtrf a mu ml smu p] performs the LU factorization of [a] (having
     bandwidths [mu] and [ml], and storage bandwidth [smu]) with partial
     pivoting according to [p]. The values in [a] are overwritten with those of
     the calculated L and U matrices. The diagonal belongs to U. The diagonal of
     L is all 1s. U may occupy elements up to bandwidth [smu] (rather than to
     [mu]).

     @cvode <node9#ss:band> bandGBTRF
     *)
    val gbtrf : t -> int -> int -> int -> Sundials.LintArray.t -> unit

    (**
     [gbtrs a smu ml p b] finds the solution of [ax = b] using LU factorization.
     [a] must be a (Square) band matrix having storage bandwidth [smu] and lower
     bandwidth [ml]. Both [p] and [b] must have the same number of rows as [a].

     @cvode <node9#ss:band> bandGBTRS
     *)
    val gbtrs : t -> int -> int -> Sundials.LintArray.t ->
      Sundials.RealArray.t -> unit
  end

