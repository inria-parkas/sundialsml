{{:https://computation.llnl.gov/casc/sundials/main.html} Sundials} is a
collection of five numerical solvers: CVODE,  CVODES, IDA, IDAS, KINSOL.
It is written by Radu Serban, Carol Woodward, and Alan Hindmarsh with the
past contributions of Peter Brown, Scott Cohen, Aaron Collier, Keith Grant,
Steven Lee, Dan Reynolds, Dan Shumaker, and Allan Taylor.
This library interfaces with Sundials version {b 2.5.0}.


This OCaml interface was written by {{:http://www.tbrk.org} Timothy Bourke}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
{{:http://www.owlnet.rice.edu/~ji2/} Jun Inoue}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
and
{{:http://www.di.ens.fr/~pouzet/} Marc Pouzet} of
{{:http://www.di.ens.fr/}ENS}.

This library provides a complete OCaml interface to Sundials.
The structure and naming conventions largely follow the original libraries,
both for ease of reading the existing documentation and for converting
existing source code, but several changes have been made for programming
convenience, namely:
- solver sessions are configured through algebraic data types rather than
  through multiple function calls,
- error conditions are signalled by exceptions rather than return codes
  (including in user-supplied callback routines),
- closures (partial applications of higher-order functions) are used to
  share user data between callback routines, and,
- explicit free commands are not necessary nor provided since OCaml is a
  garbage-collected language.

Function names have been renamed according to a regular scheme.
The leading {e module identifier} is removed and replaced with a module
path.
The identifier is renamed by separating words that begin with an
uppercase letter in by underscores and using only lowercase letters.
For instance, [CVodeSetErrHandlerFn], becomes 
[Cvode.set_err_handler_fn], and [CVSpilsSetJacTimesVecFn] becomes 
[Cvode.Spils.set_jac_times_vec_fn].

Constants have been replaced by variant types in most cases.
They have also been renamed by converting them to {e CamlCase} and removing
underscores.
For instance, [PREC_NONE] becomes [Spils.PrecNone].

Rather than try to duplicate or replace the comprehensive
{{:https://computation.llnl.gov/casc/sundials/documentation/documentation.html}
Sundials user manuals}, this documentation provides hyperlinks back to the original
function descriptions and instead tries just to include brief summaries.
These summaries have usually been directly adapted from the original manual
written by Alan C. Hindmarsh and Radu Serban of the {e Center for Applied
Scientific Computing, Lawrence Livermore National Laboratory}.

The top level {!Sundials} module provides some utility routines for dealing
with arrays of floats and integers, and for accessing certain constants
(like {!Sundials.big_real} and {!Sundials.unit_roundoff}).

{2:nvector Nvectors}

Sundials defines an abstract interface for vectors and provides
implementations for serial and parallel vectors. The OCaml version defines a
generic {!Sundials.nvector} type with type arguments indicating the
underlying data and kind (serial, parallel, or custom), and provides modules
that instantiate it (notably {!Nvector_serial}, and {!Nvector_parallel}).

The data underlying serial and parallel nvectors is passed between Sundials
and OCaml programs using Bigarrays. These vectors are manipulated within the
solver using the original low-level vector operations (cloning, linear sums,
adding constants, and etcetera). While direct interfaces to these operations
are not provided, there are equivalent implementations written in OCaml for
arrays of floats ({!Nvector_array}) and bigarrays
({!Nvector_array.Bigarray}) of floats.

There are also mechanisms for defining new vector implementations using
records of imperative ({!Nvector_custom}) or pure functions
({!Nvector_custom.Immutable}). A vector implementation for standard OCaml
arrays of floats is provided as an example ({!Nvector_array}). These
abstract nvectors may be useful for small examples, prototyping, or
debugging, but native serial (and parallel) nvectors have two important
advantages:
+ {e efficiency}, since the low-level vector operations are implemented
directly in C (rather than as C stubs around OCaml callbacks) and memory
management is simpler, and,
+ {e support} for all linear solvers, since some linear solvers do not
support abstract nvectors,

{2:modules Modules}

{!modules: Sundials
	   Dls
	   Spils
	   Nvector Nvector_serial Nvector_parallel Nvector_custom Nvector_array
	   Cvode Cvode_bbd
	   Cvodes Cvodes_bbd
	   Ida Ida_bbd
	   Idas Idas_bbd
	   Kinsol Kinsol_bbd}

{2:build Building the interface}

TODO: instructions for configuring and building the SundialsML interface.

{2:compilation Compiling programs}

TODO: Programs can be compiled using the
[-I +sundials] option and including [unix.cma] (or [.cmxa]),
[bigarray.cma] (or [.cmxa]) and [sundials_ida.cma] (or [.cmxa]), for example:
{[ocamlc -o myprogram -I +sundials unix.cma bigarray.cma sundials_ida.cma myprogram.ml]}
or:
{[ocamlopt -o myprogram -I +sundials unix.cmxa bigarray.cmxa sundials_ida.cmxa myprogram.ml]}

TODO: compiling with and without sensitivity.
TODO: compiling with and without mpi.

{2:performance Performance}

TODO: summarise performance; always slower since we add an interface layer,
but we exploit Bigarrays to minimise copying, OCaml is a memory managed
language (garbage collection, bounds checking, etc.. But, the interface does
not compare too badly:

TODO: include graph, explain methodology

TODO: performance tips for programs: a) type annotations for vectors; b)
avoid slice and sub; c) unwrap and use array access for matrices.

TODO: Thanks to OCaml's optimizations for (unboxed) floats and tight loops,
and also to the MPI and Bigarray libraries.

{2:refs References}

- A. C. Hindmarsh, P. N. Brown, K. E. Grant, S. L. Lee, R. Serban, D. E.
Shumaker, and C. S. Woodward, "{b SUNDIALS: Suite of Nonlinear and
Differential/Algebraic Equation Solvers}," ACM Transactions on Mathematical
Software, 31(3), pp. 363-396, 2005.

{2:acks Acknowledgements}

TODO: acknowledge Modrio for (partial) funding.

{2:indexes Indexes}

{!indexlist}

