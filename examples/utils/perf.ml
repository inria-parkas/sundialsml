let synopsis = 
"perf [-m <min time> | -i <input>] <n> <command>

     Measure execution time of <command> (wall-clock time), which
     should be roughly proportional to the numerical value of the
     environment variable NUM_REPS.  If -m <min time> is given,
     NUM_REPS is increased until execution time exceeds <min time>.
     If not, -i <input> must be given instead, with <input> containing
     the output from a previous execution of perf.  NUM_REPS is read
     from that file.

     Then a total of <n> measurements are taken with the same NUM_REPS.

perf -s <name> <ocaml> <sundials>

     Summarize the performance metrics generated by previous runs of
     perf.  <name> is the name of the example (usually the common
     stem of <ocaml> and <sundials>).
"

type opt = Reps of int | MinTime of float

let measure_performance reps n executable args =
  let dev_null =
    try Unix.openfile "/dev/null" [Unix.O_RDWR; Unix.O_TRUNC] 0
    with Unix.Unix_error (Unix.ENOENT, "open", "/dev/null") ->
      (* Windows *)
      try Unix.openfile "NUL" [Unix.O_RDWR; Unix.O_TRUNC] 0
      with Unix.Unix_error (Unix.ENOENT, "open", "NUL") ->
        Printf.fprintf stderr
          "ERROR: Can't find /dev/null or equivalent on your system.  \
           Giving up.  Fix prop_ida_ok in quickcheck_ida.ml and try again.";
        exit 2
  in

  (* The current environment, with NUM_REPS=* moved to index 0. *)
  let env =
    let nlen = String.length "NUM_REPS=" in
    let not_num_reps s =
      String.length s < nlen || String.sub s 0 nlen <> "NUM_REPS="
    in
    Array.of_list ("NUM_REPS=0"::List.filter not_num_reps
                     (Array.to_list (Unix.environment ())))
  in

  let pipe_read, pipe_write = Unix.pipe () in
  let pipe_read = Unix.in_channel_of_descr pipe_read in

  (* Use time(1) if one is installed and it accepts -f '%e'.
     Otherwise, use Unix.gettimeofday.  The latter is less accurate
     but more portable.  *)
  let measure =
    let spawn_wait file args stdin stdout stderr =
      let pid = Unix.create_process_env file args env stdin stdout stderr in
      let _, status = Unix.waitpid [] pid in
      match status with
      | Unix.WEXITED 0 -> ()
      | Unix.WEXITED n -> failwith ("Command exited with nonzero status "
                                    ^ string_of_int n)
      | Unix.WSIGNALED n -> failwith ("Command killed by signal "
                                      ^ string_of_int n)
      | Unix.WSTOPPED n ->
        failwith ("Command stopped by signal - execution time "
                  ^ "measurement is compromised.")
    in
    let with_gettimeofday =
      let args = Array.append [|executable|] args in
      fun num_reps ->
        env.(0) <- Printf.sprintf "NUM_REPS=%d" num_reps;
        let start = Unix.gettimeofday () in
        spawn_wait executable args dev_null dev_null Unix.stderr;
        let finish = Unix.gettimeofday () in
        finish -. start
    and with_time_command executable args =
      let args = Array.append [|"time"; "-f"; "%e"; executable|] args in
      fun num_reps ->
        env.(0) <- Printf.sprintf "NUM_REPS=%d" num_reps;
        spawn_wait "time" args dev_null dev_null pipe_write;
        Scanf.fscanf pipe_read "%f\n" (fun f -> f)
    in
    try ignore (with_time_command "true" [||] 1);
        with_time_command executable args
    with _ ->
      prerr_string
        ("Warning: can't find time(1) that accepts -f, measuring time\n" ^
         "with OCaml.  This may be slightly less accurate than time(1).\n");
      flush stderr;
      with_gettimeofday
  in

  let determine_reps min_time =
    if min_time < 0.1 then failwith "min time is too small; it should be >= 0.1";
    let rec go reps =
      let t = measure reps in
      if t >= min_time then reps, t
      else
        (* Multiply reps by min_time / t.  When t is small, this value
           is likely to be inaccurate, so we put a floor on t.  We also
           want to bump reps by at least 10% of its current value, to
           ensure quick convergence.  *)
        let next_reps =
          int_of_float (ceil (float_of_int
                                reps *. max 1.1 (min_time /. max 0.1 t)))
        in
        assert (next_reps > reps);
        go next_reps
    in go 1
  in
  (* Determine NUM_REPS.  *)
  let reps, t1 =
    match reps with
    | Reps r -> r, measure r
    | MinTime min_time -> determine_reps min_time
  in
  Printf.printf "# NUM_REPS = %d\n%.2f\n" reps t1; flush stdout;
  for i = 1 to n-1 do
    let t = measure reps in
    Printf.printf "%.2f\n" t; flush stdout;
  done

let summarize name sundials ocaml =
  let analyze file =
    let file = open_in file in
    let reps = Scanf.fscanf file "# NUM_REPS = %d\n" (fun r -> r) in
    let times = ref [] in
    begin
      try while true do
            Scanf.fscanf file "%.2f\n" (fun f -> times := f::!times)
          done;
      with End_of_file -> ()
    end;
    let sum = List.fold_left (+.) 0. !times
    and n = List.length !times in
    let mean = sum /. float_of_int n in
    reps, mean
  in
  let c_reps, c_mean = analyze sundials
  and ml_reps, ml_mean = analyze ocaml in
  if c_reps <> ml_reps then
    Printf.fprintf stderr "Warning: NUM_REPS don't match in %s and %s"
      sundials ocaml;
  Printf.printf "# name\treps\tOCaml time\tC time\tOCaml time / C time\n";
  Printf.printf "%s\t%d\t%.2f\t%.2f\t%.2f\n"
    name ml_reps ml_mean c_mean (ml_mean /. c_mean)

(* Parse args. *)

let read_pos_int s =
  try let n = int_of_string s in
    if n <= 0 then failwith ""
    else n
  with Failure _ ->
    failwith ("Error: expected positive integer but got " ^ s)
let read_pos_float s =
  try let f = float_of_string s in
    if f <= 0. then failwith ""
    else f
  with Failure "float_of_string" ->
    failwith ("Error: positive real number but got " ^ s)

let _ =
  match Array.to_list Sys.argv with
  | _::"-i"::input::n::ex::args ->
    let n = read_pos_int n in
    let reps = Scanf.fscanf (open_in input) "# NUM_REPS = %d\n" (fun r -> r) in
    measure_performance (Reps reps) n ex (Array.of_list args)
  | _::"-m"::min_time::n::ex::args ->
    let min_time = read_pos_float min_time
    and n = read_pos_int n in
    measure_performance (MinTime min_time) n ex (Array.of_list args)
  | [_;"-s";name;ocaml;sundials] ->
    summarize name sundials ocaml
  | _ ->
    print_string synopsis;
    exit 0

